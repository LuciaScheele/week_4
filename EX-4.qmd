---
title: "Similraity"
format: html
---

```{r}
library("readr")
library("dplyr")
library("sf")
```

```{r}
wildschwein <- read_delim("wildschwein_BE_2056.csv", ",")
```

```{r}
# Careful! What Timezone is assumed?
sabi <- wildschwein |>
    st_as_sf(coords = c("E", "N"), crs = 2056, remove = FALSE) |>
    filter(TierName == "Sabi", DatetimeUTC >= "2015-07-01", DatetimeUTC < "2015-07-03")
```

GGPLOT
```{r}
library(ggplot2)

ggplot(sabi, aes(E,N, color = DatetimeUTC))+
  geom_point()+
  geom_path()+
  coord_fixed() +
  scale_color_datetime(low = "blue", high = "red")+
  guides(color = guide_colorbar(title.position = "top", title.hjust= .5, barwidth= unit(2)))
```

# Distance measure for window v and segmentation
```{r}
distance_by_element <- function(later, now) {
  as.numeric(
    st_distance(later, now, by_element = TRUE)
  )
}

sabi <- sabi |>
    mutate(
        nMinus2 = distance_by_element(lag(geometry, 2), geometry),  # distance to pos -30 minutes
        nMinus1 = distance_by_element(lag(geometry, 1), geometry),  # distance to pos -15 minutes
        nPlus1  = distance_by_element(geometry, lead(geometry, 1)), # distance to pos +15 mintues
        nPlus2  = distance_by_element(geometry, lead(geometry, 2))  # distance to pos +30 minutes
    )

sabi <- sabi |>
    rowwise() |>
    mutate(
        stepMean = mean(c(nMinus2, nMinus1, nPlus1, nPlus2))
    ) |>
    ungroup()

sabi
```

# Remove static points
```{r}
sabi <- sabi |>
    mutate(static = stepMean < mean(stepMean, na.rm = TRUE))

sabi_filter <- sabi |>
    filter(!static)

sabi_filter |>
    ggplot(aes(E, N)) +
    geom_path() +
    geom_point() +
    coord_fixed() +
    theme(legend.position = "bottom")
```

# Load my own data

```{r}
install.packages("XML")
library(XML)

gpx_to_df <- function(gpx_path) {
  
  gpx_parsed <- htmlTreeParse(file = gpx_path, useInternalNodes = TRUE)
  
  # read out elements of the html file to vecotrs
coords <- xpathSApply(doc = gpx_parsed, path = "//trkpt", fun = xmlAttrs)
elevation <- xpathSApply(doc = gpx_parsed, path = "//trkpt/ele", fun = xmlValue)
time <- xpathSApply(doc = gpx_parsed, path = "//time", fun = xmlValue)
activity_name <- xpathSApply(doc = gpx_parsed, path = "//name", fun = xmlValue)


# remove first value of time, as it stems from the metadata and matches the second value (i.e. first timestamp of trackpoint)
time <- time[-1]

# convert vectors to a data frame
df <- data.frame(
  lat = as.numeric(coords["lat", ]),
  lon = as.numeric(coords["lon", ]),
  elevation = as.numeric(elevation), 
  timestamp = as.POSIXct(time,tz="UTC", format=c("%Y-%m-%dT%H:%M:%OS")),
  ActivityName = activity_name 
) 

dfname <- print(substring(gpx_path, 12, 34))

assign(dfname, df, envir = .GlobalEnv)
}
```

Apply function to all gpx-files from strava-folder: 
```{r}
# Get a list of files in the folder
folder_path <- "activities/"
file_list <- list.files(folder_path, full.names = TRUE)

# Iterate over each file and apply your function
for (file_path in file_list) {
  gpx_to_df(file_path)
}
```

# Combine single track-files to one Dataframe
Here I stitch the single dataframes containing the tracks' information together 
```{r}
#create a list of the df names
dflist <- substring(file_list,12,34)

all_tracks <- do.call(rbind, lapply(dflist, get))
```

The metadata from the 'activity' dataframe is not of any additional use. It is thus not stitched to the track data. 

# Converting the df to sf object
I convert the given dataframe to an sf-object for better handling of the spatial data and for being able to do metric calculations (ex. for distance). For this, the function needs an argument specifiying the columns that hold the spatial data, as well as the information as to which crs is being used. Here it is the lat/long crs, which is EPSG:4326 or WGS 84. 
Here it is important to specify first the longitude and then the latitude, as it is the standard convention. 

```{r}
library(sf)
all_tracks <- st_as_sf(all_tracks, coords = c("lon", "lat"), crs = 4326)
str(all_tracks)
```

## Transforming the crs 
We would like the CRS to be in the format of CH1903 +LV95 or EPSG:2056
```{r}
all_tracks <- st_transform(all_tracks, 2056)
str(all_tracks)


# Check Timezone
attr(all_tracks$timestamp, "tzone")
```

## Filtering out old data
```{r}
library(dplyr)
library(lubridate)
all_tracks <- all_tracks |> 
  mutate("year" = year(timestamp)) |> 
  filter(year == 2024)
```

# Making a map of the data
```{r}
library(tmap)

tmap_mode("view")

  tm_shape(all_tracks)+
  tm_dots(col = "ActivityName") 
```

# ex 4

## Adding coordinates 
```{r}
st_coordinates(all_tracks)

tracks <- cbind(all_tracks,st_coordinates(all_tracks))
```

## Filtern 
```{r}
home <- tracks |> filter(ActivityName == "Home")
```

